Some made up syntax for a made up documentation language.
This describes how nodes are encoded in create_node().

abstract struct Node(T1, T2) {
  field: {
    size: 2,
    name: group,
    purpose: Tags Syntax (10), Token (01), Trivium (00), and List/Missing (11).
  },
  union: {
    size: 8,
    name: T1
  },
  union: {
    size: 36,
    name: T2
  }
  field: {
    size: 20,
    name: idx,
    purpose: The unique NodeId of this Node.
  }
}

final struct Syntax extends Node(Kind, SyntaxData) {}

final struct Token extends Node(Kind, TokenData) {}

final struct Trivium extends Node(Kind, TriviumData) {}

final struct List extends Node(ChildCount, ListData) {}

final struct Missing extends Node(Zero(2), Zero(36)) {}

embedded struct SyntaxData {
  embed ParentIndex(14),
  embed FirstChildSiblingId
}

embedded struct TokenData {
  embed ParentIndex(14),
  embed TokenTextTriviumOffset
}

embedded struct TriviumData {
  embed ParentIndex(10),
  embed SourceByteOffset
}

embedded struct ListData {
  embed ParentIndex(14),
  embed ChildCount
}

embedded struct Kind {
  field: {
    size 8,
    name: kind,
    purpose: The InternedString<Kind> which uniquely identifies the kind of this
             Node when combined with the field "group".
  }
}

embedded struct ParentDiff(T) {
  field: {
    size: T,
    name: parent_diff,
    purpose: The difference between the NodeId of the current node and that of
             its parent. In special cases, this value is `0`. For example,
             SCRIPT_NODE is its own parent, so the distance is 0. When the
             difference with the parent cannot be encoded in the bit width of
             this field, the value will be set to 0. The signals to the consumers
             that they must use a slow path to reconstruct the relation with
             their parent.
  },
}

embedded struct FirstChildSiblingId {
  field: {
    size: 20,
    name: first_child_sibling_id,
    purpose: The SiblingId of the first child of this Node.
  }
}

embedded struct TokenTextTriviumOffset {
  field: {
    size: 20,
    name: token_text_trivium_offset,
    purpose: The NodeId of the Trivium that has the text of this Token.
  }
}

embedded struct SourceByteOffset {
  field: {
    size: 24,
    name: source_byte_offset,
    purpose: The index of the first byte in the source text.
  }
}

embedded struct ChildCount {
  field: {
    size: 8,
    name: child_count,
    purpose: The size of this list, or 255 to signify lists of length 255+.
  }
}

embedded struct Zero(T) {
  field: {
    size: T,
    name: _,
    value: 0,
    purpose: All zeroed out bytes.
  }
}

// Expanded views of all the final structs

final struct Syntax {
  field: {
    size: 2,
    name: group,
    value: 10,
    purpose: Tags Syntax (10), Token (01), Trivium (00), and List/Missing (11).
  },
  field: {
    size 8,
    name: kind,
    purpose: The InternedString<Kind> which uniquely identifies the kind of this
             Node when combined with the field "group".
  },
  field: {
    size: 14,
    name: parent_diff,
    purpose: The difference between the NodeId of the current node and that of
             its parent. In special cases, this value is `0`. For example,
             SCRIPT_NODE is its own parent, so the distance is 0. When the
             difference with the parent cannot be encoded in the bit width of
             this field, the value will be set to 0. The signals to the consumers
             that they must use a slow path to reconstruct the relation with
             their parent.
  },
  field: {
    size: 20,
    name: first_child_sibling_id,
    purpose: The SiblingId of the first child of this Node.
  },
  field: {
    size: 20,
    name: idx,
    purpose: The unique NodeId of this Node.
  }
}

final struct Token {
  field: {
    size: 2,
    name: group,
    value: 01,
    purpose: Tags Syntax (10), Token (01), Trivium (00), and List/Missing (11).
  },
  field: {
    size 8,
    name: kind,
    purpose: The InternedString<Kind> which uniquely identifies the kind of this
             Node when combined with the field "group".
  },
  field: {
    size: 14,
    name: parent_diff,
    purpose: The difference between the NodeId of the current node and that of
             its parent. In special cases, this value is `0`. For example,
             SCRIPT_NODE is its own parent, so the distance is 0. When the
             difference with the parent cannot be encoded in the bit width of
             this field, the value will be set to 0. The signals to the consumers
             that they must use a slow path to reconstruct the relation with
             their parent.
  },
  field: {
    size: 20,
    name: token_text_trivium_offset,
    purpose: The NodeId of the Trivium that has the text of this Token.
  }
  field: {
    size: 20,
    name: idx,
    purpose: The unique NodeId of this Node.
  }
}

final struct Trivium {
  field: {
    size: 2,
    name: group,
    value: 00,
    purpose: Tags Syntax (10), Token (01), Trivium (00), and List/Missing (11).
  },
  field: {
    size 8,
    name: kind,
    purpose: The InternedString<Kind> which uniquely identifies the kind of this
             Node when combined with the field "group".
  },
  field: {
    size: 10,
    name: parent_diff,
    purpose: The difference between the NodeId of the current node and that of
             its parent. In special cases, this value is `0`. For example,
             SCRIPT_NODE is its own parent, so the distance is 0. When the
             difference with the parent cannot be encoded in the bit width of
             this field, the value will be set to 0. The signals to the consumers
             that they must use a slow path to reconstruct the relation with
             their parent.
  },
  field: {
    size: 24,
    name: source_byte_offset,
    purpose: The index of the first byte in the source text.
  }
  field: {
    size: 20,
    name: idx,
    purpose: The unique NodeId of this Node.
  }
}

final struct List {
  field: {
    size: 2,
    name: group,
    value: 11,
    purpose: Tags Syntax (10), Token (01), Trivium (00), and List/Missing (11).
  },
  field: {
    size: 8,
    name: child_count,
    purpose: The size of this list, or 255 to signify lists of length 255+.
  }
  field: {
    size: 14,
    name: parent_diff,
    purpose: The difference between the NodeId of the current node and that of
             its parent. In special cases, this value is `0`. For example,
             SCRIPT_NODE is its own parent, so the distance is 0. When the
             difference with the parent cannot be encoded in the bit width of
             this field, the value will be set to 0. The signals to the consumers
             that they must use a slow path to reconstruct the relation with
             their parent.
  },
  field: {
    size: 20,
    name: first_child_sibling_id,
    purpose: The SiblingId of the first child of this Node.
  },
  field: {
    size: 20,
    name: idx,
    purpose: The unique NodeId of this Node.
  }
}

final struct Missing {
  field: {
    size: 2,
    name: group,
    value: 11,
    purpose: Tags Syntax (10), Token (01), Trivium (00), and List/Missing (11).
  },
  field: {
    size: 8,
    name: _,
    value: 0,
    purpose: All zeroed out bytes.
  }
  field: {
    size: 14,
    name: parent_diff,
    purpose: The difference between the NodeId of the current node and that of
             its parent. In special cases, this value is `0`. For example,
             SCRIPT_NODE is its own parent, so the distance is 0. When the
             difference with the parent cannot be encoded in the bit width of
             this field, the value will be set to 0. The signals to the consumers
             that they must use a slow path to reconstruct the relation with
             their parent.
  },
  field: {
    size: 20,
    name: _,
    value: 0,
    purpose: All zeroed out bytes.
  }
  field: {
    size: 20,
    name: idx,
    purpose: The unique NodeId of this Node.
  }
}
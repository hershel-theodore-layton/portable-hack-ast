#!/usr/bin/env hhvm
/** portable-hack-ast is MIT licensed, see /LICENSE. */
namespace HTL\Pha\_Private\Bin;

use namespace HH\Lib\{C, Dict, File, Keyset, Str, Vec};
use function escapeshellarg, var_export_pure;

const string CACHE_DIR = __DIR__.'/../.var/cache/curl_cache/';
const string GENERATED = "// #region GENERATED CODE DO NOT EDIT BY HAND!\n";

<<__EntryPoint>>
async function codegen_kind_constants_async()[defaults]: Awaitable<void> {
  \shell_exec('mkdir -p '.escapeshellarg(CACHE_DIR));
  $argv = \HH\global_get('argv') as vec<_> |> Vec\map($$, $x ==> $x as string);
  $commits = Vec\slice($argv, 1);

  list($syntaxes, $tokens) = await mixin_hhvm_next_commits_async($commits);

  $sort = $things ==> Dict\sort_by_key(
    $things,
    ($a, $b) ==> Str\uppercase($a) <=> Str\uppercase($b),
  );

  $sort_with_keyset_values = $things ==> Dict\sort_by_key(
    $things,
    ($a, $b) ==> Str\uppercase($a) <=> Str\uppercase($b),
  );

  $calling_card = Str\format(
    "// This code was generated by bin/codegen_kind_constants.hack %s\n\n",
    Str\join($commits, ' '),
  );

  $kind_constants = GENERATED.$calling_card;

  $ambiguous_kinds = Keyset\intersect(Vec\keys($syntaxes), Vec\keys($tokens));

  $syntax_kind_to_const = Dict\map_with_key(
    $syntaxes,
    ($kind, $_) ==> 'KIND_'.
      Str\uppercase(
        C\contains_key($ambiguous_kinds, $kind) ? $kind.'_SYNTAX' : $kind,
      ),
  );

  $token_kind_to_const = Dict\map_with_key(
    $tokens,
    ($kind, $_) ==> 'KIND_'.
      Str\uppercase(
        C\contains_key($ambiguous_kinds, $kind) ? $kind.'_TOKEN' : $kind,
      ),
  );

  // @historical_artifact: KIND_END_OF_FILE was the name of the syntax,
  // not the token. Override to keep it that way.
  $syntax_kind_to_const['end_of_file'] = 'KIND_END_OF_FILE';

  foreach ($sort_with_keyset_values($syntaxes) as $name => $_) {
    $kind_constants .= Str\format(
      "const SyntaxKind %s = %s;\n",
      $syntax_kind_to_const[$name],
      var_export_pure($name) as string,
    );
  }

  $kind_constants .= "\n";

  foreach ($sort($tokens) as $name => $repr) {
    $kind_constants .= Str\format(
      "const TokenKind %s = %s;\n",
      $token_kind_to_const[$name],
      var_export_pure($repr) as string,
    );
  }

  $kind_constants .= "// #endregion\n";

  $kind_file = File\open_read_write(__DIR__.'/../src/Kind.hack');
  using (
    $kind_file->closeWhenDisposed(),
    $kind_file->tryLockx(File\LockType::EXCLUSIVE)
  ) {
    $kind_functions = await $kind_file->readAllAsync()
      |> Str\slice($$, 0, Str\search($$, GENERATED) ?? Str\length($$));
    $kind_file->seek(0);
    $kind_file->truncate();
    await $kind_file->writeAllAsync($kind_functions.$kind_constants);
  }

  $member_to_owner = dict[];

  foreach ($syntaxes as $owner => $members) {
    foreach ($members as $member) {
      $member_to_owner[$member] = $owner;
    }
  }

  $member_constants = GENERATED.$calling_card;

  foreach (Dict\sort_by_key($member_to_owner) as $member => $owner) {
    $member_constants .= Str\format(
      "const Member MEMBER_%s = tuple(%s, %s);\n",
      Str\uppercase($member),
      $syntax_kind_to_const[$owner],
      var_export_pure($member) as string,
    );
  }

  $member_constants .= "// #endregion\n";

  $member_file = File\open_read_write(__DIR__.'/../src/Member.hack');
  using (
    $member_file->closeWhenDisposed(),
    $member_file->tryLockx(File\LockType::EXCLUSIVE)
  ) {
    $member_functions = await $member_file->readAllAsync()
      |> Str\slice($$, 0, Str\search($$, GENERATED) ?? Str\length($$));
    $member_file->seek(0);
    $member_file->truncate();
    await $member_file->writeAllAsync($member_functions.$member_constants);
  }
}
